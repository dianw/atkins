<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atkins WebSocket Chat Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/protobufjs@7.2.5/dist/protobuf.min.js"></script>
    <style>
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>
    <div id="app" class="h-screen bg-gray-100 flex">
        <!-- Sidebar with conversations -->
        <div class="w-1/3 bg-white border-r border-gray-200 flex flex-col">
            <!-- Header -->
            <div class="p-4 border-b border-gray-200 flex justify-between items-center">
                <h1 class="text-xl font-semibold text-gray-800">Conversations</h1>
                <div class="flex space-x-2">
                    <button
                        @click="loadConversations"
                        class="bg-gray-500 hover:bg-gray-600 text-white rounded-full w-8 h-8 flex items-center justify-center transition-colors"
                        title="Refresh Conversations"
                    >
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                    </button>
                    <button
                        @click="openNewConversationModal"
                        class="bg-blue-500 hover:bg-blue-600 text-white rounded-full w-8 h-8 flex items-center justify-center transition-colors"
                        title="New Conversation"
                    >
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Connection Status -->
            <div class="px-4 py-2 border-b border-gray-200">
                <div class="flex items-center space-x-2">
                    <div class="w-2 h-2 rounded-full" :class="connectionStatusClass"></div>
                    <span class="text-sm font-medium" :class="connectionTextClass">{{ connectionStatus }}</span>
                </div>
            </div>

            <!-- Conversations List -->
            <div class="flex-1 overflow-y-auto scrollbar-hide">
                <!-- Loading state -->
                <div v-if="loadingConversations" class="p-4 text-center">
                    <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
                    <p class="text-sm text-gray-500 mt-2">Loading conversations...</p>
                </div>
                
                <!-- Error state -->
                <div v-else-if="conversationsError" class="p-4 text-center">
                    <p class="text-sm text-red-500 mb-2">{{ conversationsError }}</p>
                    <button
                        @click="loadConversations"
                        class="text-blue-500 hover:text-blue-600 text-sm underline"
                    >
                        Retry
                    </button>
                </div>
                
                <!-- Empty state -->
                <div v-else-if="conversations.length === 0" class="p-4 text-center text-gray-500">
                    No conversations yet
                </div>
                
                <!-- Conversations -->
                <div
                    v-else
                    v-for="conversation in conversations"
                    :key="conversation.conversationId"
                    @click="selectConversation(conversation)"
                    class="p-3 border-b border-gray-100 hover:bg-gray-50 cursor-pointer transition-colors"
                    :class="{ 'bg-blue-50 border-blue-200': selectedConversation?.conversationId === conversation.conversationId }"
                >
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <div class="flex items-center space-x-2">
                                <h3 class="font-medium text-gray-900 truncate">
                                    {{ getConversationTitle(conversation) }}
                                </h3>
                                <span v-if="conversation.unread_count > 0"
                                      class="bg-blue-500 text-white text-xs rounded-full px-2 py-1 min-w-[20px] text-center">
                                    {{ conversation.unread_count }}
                                </span>
                            </div>
                            <p v-if="conversation.lastMessage" class="text-sm text-gray-600 truncate mt-1">
                                {{ conversation.lastMessage.content }}
                            </p>
                        </div>
                        <span v-if="conversation.lastUpdatedTimestamp" class="text-xs text-gray-400">
                            {{ formatTime(conversation.lastUpdatedTimestamp) }}
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="flex-1 flex flex-col">
            <!-- Chat Header -->
            <div v-if="selectedConversation" class="p-4 border-b border-gray-200 bg-white">
                <h2 class="text-lg font-semibold text-gray-800">{{ getConversationTitle(selectedConversation) }}</h2>
                <div class="flex items-center space-x-2 mt-1">
                    <div class="flex -space-x-2">
                        <div v-for="participant in selectedConversation.participants"
                             :key="participant.user_id"
                             class="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center text-white text-xs border-2 border-white"
                             :title="participant.display_name || participant.username">
                            {{ (participant.display_name || participant.username) }}
                        </div>
                    </div>
                    <span class="text-sm text-gray-500">{{ selectedConversation.participants.length }} participants</span>
                </div>
            </div>

            <!-- Welcome Message -->
            <div v-if="!selectedConversation" class="flex-1 flex items-center justify-center bg-gray-50">
                <div class="text-center">
                    <div class="w-16 h-16 bg-gray-300 rounded-full flex items-center justify-center mx-auto mb-4">
                        <svg class="w-8 h-8 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                        </svg>
                    </div>
                    <h3 class="text-lg font-medium text-gray-900 mb-2">Select a conversation</h3>
                    <p class="text-gray-500">Choose a conversation from the sidebar or start a new one</p>
                </div>
            </div>

            <!-- Messages -->
            <div v-if="selectedConversation" class="flex-1 overflow-y-auto p-4 space-y-3 bg-gray-50 scrollbar-hide" ref="messagesContainer">
                <div v-for="message in messages" :key="message.message_id" class="flex" :class="{ 'justify-end': message.my_message }">
                    <div class="max-w-xs lg:max-w-md px-4 py-2 rounded-lg" :class="messageClass(message)">
                        <div v-if="!message.my_message" class="text-xs text-gray-600 mb-1">
                            {{ message.sender?.display_name || message.sender?.username || 'Unknown' }}
                        </div>
                        <div class="text-sm">{{ message.content }}</div>
                        <div class="text-xs mt-1" :class="message.my_message ? 'text-blue-200' : 'text-gray-500'">
                            {{ formatTime(message.timestamp) }}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Message Input -->
            <div v-if="selectedConversation" class="p-4 bg-white border-t border-gray-200">
                <div class="flex space-x-3">
                    <input
                        v-model="newMessage"
                        @keypress.enter="sendMessage"
                        type="text"
                        placeholder="Type a message..."
                        class="flex-1 border border-gray-300 rounded-lg px-4 py-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        :disabled="!isConnected"
                    >
                    <button
                        @click="sendMessage"
                        :disabled="!isConnected || !newMessage.trim()"
                        class="bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
                    >
                        Send
                    </button>
                </div>
            </div>
        </div>

        <!-- New Conversation Modal -->
        <div v-if="showNewConversationModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 w-96 max-w-90vw">
                <h3 class="text-lg font-semibold mb-4">Start New Conversation</h3>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Select Participants</label>

                        <!-- Loading state -->
                        <div v-if="loadingParticipants" class="text-center py-4">
                            <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
                            <p class="text-sm text-gray-500 mt-2">Loading participants...</p>
                        </div>

                        <!-- Error state -->
                        <div v-else-if="participantsError" class="text-center py-4">
                            <p class="text-sm text-red-500 mb-2">{{ participantsError }}</p>
                            <button
                                @click="loadParticipants"
                                class="text-blue-500 hover:text-blue-600 text-sm underline"
                            >
                                Retry
                            </button>
                        </div>

                        <!-- Participants list -->
                        <div v-else class="max-h-60 overflow-y-auto border border-gray-300 rounded-lg">
                            <div v-if="availableParticipants.length === 0" class="p-4 text-center text-gray-500">
                                No participants available
                            </div>
                            <div v-else>
                                <div
                                    v-for="participant in availableParticipants"
                                    :key="participant.user_id"
                                    class="flex items-center p-3 hover:bg-gray-50 border-b border-gray-100 last:border-b-0"
                                >
                                    <input
                                        type="radio"
                                        :id="'participant-' + participant.user_id"
                                        :value="participant"
                                        v-model="selectedParticipants"
                                        class="mr-3 rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                                    >
                                    <label
                                        :for="'participant-' + participant.user_id"
                                        class="flex-1 cursor-pointer"
                                    >
                                        <div class="flex items-center space-x-3">
                                            <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white text-sm">
                                                {{ (participant.display_name || participant.username) }}
                                            </div>
                                            <div>
                                                <div class="font-medium text-gray-900">
                                                    {{ participant.username || participant.user_id }}
                                                </div>
                                                <div v-if="participant" class="text-sm text-gray-500">
                                                    @{{ participant.display_name || participant.username }}
                                                </div>
                                            </div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <!-- Selected count -->
                        <div v-if="selectedParticipants" class="mt-2 text-sm text-gray-600">
                            Selected: {{ selectedParticipants.username }}
                        </div>
                    </div>
                    <div class="flex space-x-3">
                        <button
                            @click="startConversation"
                            :disabled="!selectedParticipants || loadingParticipants"
                            class="flex-1 bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors"
                        >
                            Start Conversation
                        </button>
                        <button
                            @click="showNewConversationModal = false; selectedParticipants = null"
                            class="flex-1 bg-gray-200 text-gray-800 py-2 rounded-lg hover:bg-gray-300 transition-colors"
                        >
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    socket: null,
                    root: null,
                    isConnected: false,
                    conversations: [],
                    selectedConversation: null,
                    messages: [],
                    newMessage: '',
                    showNewConversationModal: false,
                    newConversationParticipants: '',
                    requestCounter: 0,
                    availableParticipants: [],
                    selectedParticipants: null,
                    loadingParticipants: false,
                    participantsError: null,
                    loadingConversations: false,
                    conversationsError: null
                };
            },
            computed: {
                connectionStatus() {
                    return this.isConnected ? 'Connected' : 'Disconnected';
                },
                connectionStatusClass() {
                    return this.isConnected ? 'bg-green-500' : 'bg-red-500';
                },
                connectionTextClass() {
                    return this.isConnected ? 'text-green-700' : 'text-red-700';
                }
            },
            async mounted() {
                await this.loadProtobuf();
                this.connect();
                // Load conversations via HTTP regardless of WebSocket connection status
                await this.loadConversations();
            },
            methods: {
                async loadProtobuf() {
                    try {
                        console.log('Loading protobuf schema...');
                        
                        // Define the complete protobuf schema with inline Timestamp definition
                        const protoSchema = `
                            syntax = "proto3";

                            package org.enkrip.atkins.proto;

                            option java_package = "org.enkrip.atkins.proto";
                            option java_outer_classname = "ChatRpcProto";
                            option java_multiple_files = true;

                            // Inline Timestamp definition to avoid import issues
                            message Timestamp {
                              int64 seconds = 1;
                              int32 nanos = 2;
                            }

                            // Main RPC envelope message
                            message RPCRequestEnvelope {
                              string request_id = 1; // Unique ID for the request/response pair
                              MessageType message_type = 2; // Type of message: REQUEST, RESPONSE, NOTIFICATION
                              MessageOperationType operation_type = 3; // Specific operation being performed

                              oneof payload {
                                GetListOfConversationsRequest get_list_of_conversations_request = 4;
                                StartConversationRequest start_conversation_request = 5;
                                SendConversationMessageRequest send_conversation_message_request = 6;
                              }
                            }

                            message RPCResponseEnvelope {
                              string request_id = 1; // Unique ID for the request/response pair
                              MessageType message_type = 2; // Type of message: REQUEST, RESPONSE, NOTIFICATION
                              MessageOperationType operation_type = 3; // Specific operation being performed
                              bool success = 4; // Indicates if the operation was successful
                              string error_code = 5; // Error message if success is false
                              string error_message = 6; // Error message if success is false

                              oneof payload {
                                GetListOfConversationsResponse get_list_of_conversations_response = 7;
                                StartConversationResponse start_conversation_response = 8;
                                SendConversationMessageResponse send_conversation_message_response = 9;
                                ReceiveConversationMessageNotification receive_conversation_message_notification = 10;
                              }
                            }

                            message GetListOfConversationsRequest {
                              optional string before_conversation_id = 1; // For pagination: fetch conversations before this ID
                              int32 limit = 3; // Maximum number of conversations to fetch
                            }

                            message GetListOfConversationsResponse {
                              repeated Conversation conversations = 1; // List of conversations
                              bool has_more = 2; // Indicates if there are more conversations before the fetched list
                              string last_conversation_id = 3; // ID of the last conversation in the fetched list for pagination
                            }

                            message StartConversationRequest {
                              repeated string participant_user_ids = 1; // User IDs of participants to start a conversation with
                            }

                            message StartConversationResponse {
                              Conversation conversation = 1; // The newly created conversation
                            }

                            message SendConversationMessageRequest {
                              string conversation_id = 1; // ID of the conversation to send the message to
                              ChatMessageType message_type = 2; // Type of message: TEXT, IMAGE, FILE
                              string content = 3; // Content of the message (text or URL to file/image)
                            }

                            message SendConversationMessageResponse {
                              ChatMessage message = 1; // The sent message
                            }

                            message ReceiveConversationMessageNotification {
                              ChatMessage message = 1; // The received message
                            }

                            message Conversation {
                              string conversation_id = 1;
                              optional ChatMessage last_message = 2;
                              repeated ChatUser participants = 3;
                              Timestamp last_updated_timestamp = 4; // Unix timestamp of the last update
                              int32 version = 5; // Version number for concurrency control
                              int32 unread_count = 6; // Number of unread messages in the conversation
                            }

                            message ChatMessage {
                              string message_id = 1;
                              optional string conversation_id = 2;
                              optional ChatUser sender = 3;
                              Timestamp timestamp = 4; // Unix timestamp of when the message was sent
                              ChatMessageType message_type = 5; // Type of message: TEXT, IMAGE, FILE
                              string content = 6; // Content of the message (text or URL to file/image)
                              bool my_message = 7; // Indicates if the message was sent by the current user
                              bool read = 8; // Indicates if the message has been read by the recipient(s)
                              int32 version = 9; // Version number for concurrency control
                            }

                            message ChatUser {
                              string user_id = 1;
                              string username = 2;
                              optional string display_name = 3;
                              optional string avatar_url = 4; // URL to the user's avatar image
                            }

                            enum MessageOperationType {
                              GET_LIST_OF_CONVERSATIONS = 0;
                              GET_CONVERSATION = 1;
                              START_CONVERSATION = 2;
                              DELETE_CONVERSATION = 3;
                              SEND_CONVERSATION_MESSAGE = 4;
                              DELETE_CONVERSATION_MESSAGE = 5;
                              RECEIVE_CONVERSATION_MESSAGE = 6;
                              MARK_CONVERSATION_AS_READ = 7;
                              TYPING_INDICATOR = 8;
                            }

                            enum MessageType {
                              REQUEST = 0;
                              RESPONSE = 1;
                              NOTIFICATION = 2;
                            }

                            enum ChatMessageType {
                              TEXT = 0;
                              IMAGE = 1;
                              FILE = 2;
                              EMOJI = 3;
                            }
                        `;

                        console.log('Parsing protobuf schema...');
                        
                        // Parse the schema using protobuf.js
                        const parsed = protobuf.parse(protoSchema);
                        this.root = parsed.root;
                        
                        console.log('Protobuf schema loaded successfully');
                        
                        // Test type lookup to verify everything is working
                        const testType = this.root.lookupType('org.enkrip.atkins.proto.RPCRequestEnvelope');
                        console.log('RPCRequestEnvelope type found:', !!testType);
                        
                        if (testType) {
                            console.log('RPCRequestEnvelope fields:', Object.keys(testType.fields));
                            
                            // Test simple message creation
                            const testEnvelope = {
                                requestId: 'test_123',
                                messageType: 0,
                                operationType: 0
                            };
                            
                            console.log('Testing simple message creation...');
                            const testMessage = testType.create(testEnvelope);
                            console.log('Test message created successfully');
                            
                            const testBuffer = testType.encode(testMessage).finish();
                            console.log('Test encoding successful, buffer length:', testBuffer.length);
                        }
                    } catch (error) {
                        console.error('Failed to load protobuf schema:', error);
                        console.error('Error details:', error.message);
                        console.error('Stack trace:', error.stack);
                    }
                },

                connect() {
                    try {
                        this.socket = new WebSocket('ws://localhost:8080/websocket/chat');
                        this.socket.binaryType = 'arraybuffer';

                        this.socket.onopen = () => {
                            console.log('WebSocket connection opened');
                            this.isConnected = true;
                            // Load conversations via HTTP instead of WebSocket
                            this.loadConversations();
                        };

                        this.socket.onmessage = (event) => {
                            this.handleMessage(event.data);
                        };

                        this.socket.onclose = () => {
                            console.log('WebSocket connection closed');
                            this.isConnected = false;
                            // Attempt to reconnect after 3 seconds
                            setTimeout(() => {
                                if (!this.isConnected) {
                                    this.connect();
                                }
                            }, 3000);
                        };

                        this.socket.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            this.isConnected = false;
                        };

                    } catch (error) {
                        console.error('Failed to create WebSocket connection:', error);
                    }
                },

                handleMessage(data) {
                    try {
                        const ResponseEnvelope = this.root.lookupType('org.enkrip.atkins.proto.RPCResponseEnvelope');
                        const message = ResponseEnvelope.decode(new Uint8Array(data));
                        console.log('Received message:', message);

                        switch (message.operationType) {
                            case 2: // START_CONVERSATION
                                if (message.startConversationResponse) {
                                    // Reload conversations via HTTP to get the new conversation
                                    this.loadConversations();
                                    this.selectConversation(message.startConversationResponse.conversation);
                                    this.showNewConversationModal = false;
                                    this.selectedParticipants = null;
                                }
                                break;
                            case 4: // SEND_CONVERSATION_MESSAGE
                                if (message.sendConversationMessageResponse) {
                                    this.messages.push(message.sendConversationMessageResponse.message);
                                    this.scrollToBottom();
                                }
                                break;
                            case 6: // RECEIVE_CONVERSATION_MESSAGE
                                if (message.receiveConversationMessageNotification) {
                                    const newMessage = message.receiveConversationMessageNotification.message;
                                    if (this.selectedConversation &&
                                        newMessage.conversationId === this.selectedConversation.conversationId) {
                                        this.messages.push(newMessage);
                                        this.scrollToBottom();
                                    }
                                    // Update conversation list
                                    this.updateConversationLastMessage(newMessage);
                                }
                                break;
                        }
                    } catch (error) {
                        console.error('Failed to decode message:', error);
                    }
                },

                sendProtobufMessage(envelope) {
                    if (!this.isConnected || !this.socket) {
                        console.error('WebSocket not connected');
                        return;
                    }

                    if (!this.root) {
                        console.error('Protobuf root not loaded');
                        return;
                    }

                    try {
                        console.log('Sending envelope:', JSON.stringify(envelope, null, 2));
                        const RequestEnvelope = this.root.lookupType('org.enkrip.atkins.proto.RPCRequestEnvelope');
                        console.log('RequestEnvelope type found:', !!RequestEnvelope);
                        
                        // Validate the envelope structure
                        console.log('Envelope validation:');
                        console.log('- requestId:', envelope.requestId);
                        console.log('- messageType:', envelope.messageType);
                        console.log('- operationType:', envelope.operationType);
                        console.log('- payload keys:', Object.keys(envelope).filter(k => !['requestId', 'messageType', 'operationType'].includes(k)));
                        
                        const message = RequestEnvelope.create(envelope);
                        console.log('Created message:', message);
                        
                        const errorMsg = RequestEnvelope.verify(message);
                        if (errorMsg) throw Error(`Protobuf verification failed: ${errorMsg}`);
                        
                        const buffer = RequestEnvelope.encode(message).finish();
                        console.log('Encoded buffer:', buffer);
                        console.log('Encoded buffer length:', buffer.length);
                        console.log('Encoded buffer bytes:', Array.from(buffer).map(b => b.toString(16).padStart(2, '0')).join(' '));
                        
                        this.socket.send(buffer);
                        console.log('Message sent successfully');
                    } catch (error) {
                        console.error('Failed to send message:', error);
                        console.error('Envelope that failed:', envelope);
                        console.error('Error stack:', error.stack);
                    }
                },

                generateRequestId() {
                    return `req_${Date.now()}_${++this.requestCounter}`;
                },

                async loadConversations() {
                    this.loadingConversations = true;
                    this.conversationsError = null;
                    
                    try {
                        const response = await fetch('/api/chat/conversations');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const conversations = await response.json();
                        this.conversations = Array.isArray(conversations) ? conversations : Array.from(conversations);
                        console.log('Loaded conversations:', this.conversations);
                    } catch (error) {
                        console.error('Failed to load conversations:', error);
                        this.conversationsError = 'Failed to load conversations. Please try again.';
                        this.conversations = [];
                    } finally {
                        this.loadingConversations = false;
                    }
                },

                startConversation() {
                    if (!this.selectedParticipants) {
                        console.error('No participant selected');
                        return;
                    }

                    const envelope = {
                        requestId: this.generateRequestId(),
                        messageType: 0, // REQUEST
                        operationType: 2, // START_CONVERSATION
                        startConversationRequest: {
                            participantUserIds: [this.selectedParticipants.username]
                        }
                    };
                    console.log('Sending start conversation request:', envelope);
                    this.sendProtobufMessage(envelope);
                },

                selectConversation(conversation) {
                    this.selectedConversation = conversation;
                    this.messages = []; // Clear current messages
                    // In a real app, you would load messages for this conversation
                },

                sendMessage() {
                    if (!this.newMessage.trim() || !this.selectedConversation) return;

                    const envelope = {
                        requestId: this.generateRequestId(),
                        messageType: 0, // REQUEST
                        operationType: 4, // SEND_CONVERSATION_MESSAGE
                        sendConversationMessageRequest: {
                            conversationId: this.selectedConversation.conversationId,
                            messageType: 0, // TEXT
                            content: this.newMessage.trim()
                        }
                    };

                    this.sendProtobufMessage(envelope);
                    this.newMessage = '';
                },

                updateConversationLastMessage(message) {
                    const conversation = this.conversations.find(c => c.conversationId === message.conversationId);
                    if (conversation) {
                        conversation.lastMessage = message;
                        conversation.lastUpdatedTimestamp = message.timestamp;
                        if (!message.myMessage) {
                            conversation.unreadCount = (conversation.unreadCount || 0) + 1;
                        }
                    }
                },

                getConversationTitle(conversation) {
                    if (!conversation.participants || conversation.participants.length === 0) {
                        return 'Unknown Conversation';
                    }
                    return conversation.conversationId;
                },

                messageClass(message) {
                    return message.myMessage
                        ? 'bg-blue-500 text-white'
                        : 'bg-white text-gray-800 border border-gray-200';
                },

                formatTime(timestamp) {
                    if (!timestamp) return '';
                    
                    // Handle Google Protobuf Timestamp format
                    let date;
                    if (typeof timestamp === 'object' && timestamp.seconds !== undefined) {
                        // Google Protobuf Timestamp format: {seconds: number, nanos: number}
                        const seconds = typeof timestamp.seconds === 'string' ? parseInt(timestamp.seconds) : timestamp.seconds;
                        const nanos = timestamp.nanos || 0;
                        date = new Date(seconds * 1000 + nanos / 1000000);
                    } else if (typeof timestamp === 'number') {
                        // Simple timestamp in milliseconds
                        date = new Date(timestamp);
                    } else {
                        return '';
                    }
                    
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                },

                scrollToBottom() {
                    this.$nextTick(() => {
                        const container = this.$refs.messagesContainer;
                        if (container) {
                            container.scrollTop = container.scrollHeight;
                        }
                    });
                },

                async openNewConversationModal() {
                    this.showNewConversationModal = true;
                    this.selectedParticipants = null;
                    await this.loadParticipants();
                },

                async loadParticipants() {
                    this.loadingParticipants = true;
                    this.participantsError = null;

                    try {
                        const response = await fetch('/api/chat/participants');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const participantUsernames = await response.json();

                        // Convert the array of usernames to participant objects
                        this.availableParticipants = participantUsernames.map(username => ({
                            user_id: username,
                            username: username,
                            display_name: username // Use username as display name since that's what we get from the API
                        }));
                    } catch (error) {
                        console.error('Failed to load participants:', error);
                        this.participantsError = 'Failed to load participants. Please try again.';
                    } finally {
                        this.loadingParticipants = false;
                    }
                },

                closeNewConversationModal() {
                    this.showNewConversationModal = false;
                    this.selectedParticipants = null;
                    this.participantsError = null;
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
